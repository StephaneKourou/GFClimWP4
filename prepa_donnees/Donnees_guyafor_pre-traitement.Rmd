---
title: "Pré-traitement des données Guyafor pour le modèle GFClim WP4"
author: "StephaneKourou"
date: "`r format(Sys.time(), '%d %B %Y')`"
output:
  html_document:
    fig_caption: yes
    highlight: pygments
    number_sections: no
    theme: journal
    toc: yes
    toc_depth: 5
    toc_float: yes
  word_document:
    toc: yes
    toc_depth: '5'
---


<!-- Options de knitr et de R (librairies, ...) --> 

```{r nettoyage, echo=FALSE, message=FALSE,warning=FALSE}
# on commence par faire le menage
rm(list=ls(all=TRUE))
gc() # garbage collector
```

```{r Bibliotheque, echo=FALSE, message=FALSE,warning=FALSE}
knitr::opts_chunk$set(cache=TRUE, warning=FALSE, tidy=TRUE, tidy.opts=list(blank=FALSE, width.cutoff=40))
# Installation des packages si necessaire et chargement
Library <- function(Packages) {
  InstallAndLoad <- function(Package) {
    if (!Package %in% installed.packages()[, 1]) {install.packages(Package)}
    require(Package, character.only = TRUE)
  }
  invisible(sapply(Packages, InstallAndLoad))
}

# Ajouter les packages necessaires ici
Library(c("knitr","tidyverse","dplyr","BIOMASS"))
```

<!-- Debut du document ci-dessous --> 
 
# Résumé
Mise au format des données Guyafor pour modele joint croissance mortalité à faire tourner sous Stan.
Pour les accroissements et les indices d'intensité d'exploitation, les données de base sont issues d'une extraction de Guyafor : DataParacouV6.R : cree dispoGuyafor 1887076 obs et 31 variables.
Un indice de stress hydrique et d'intensité d'exploitation forestière sont égalemnt calculé pour chaque accroissement.
Un Dmax est calculé pour chaque espèce et chaque site quand les données le permettent.


# 1 Création données arbres, calcul Dmax par site et par espece 
Le fichier **Data_guyafor_16esp_Cl_join.Rdata** contient le résultat de ce script, paramètres (nbmin_arbres=0 ; nbmin_mes=3 ; an_min_meteo=1968 ; REW multisite)

Le fichier **Data_guyafor_16esp_S0_to_join.Rdata** contient le résultat de ce script, paramètres (nbmin_arbres=0 ; nbmin_mes=3 ; an_min_meteo=1978)


##A Paramètrage de l'étape 1
Nombre minimal d'individus par espece et par site : 
  -fixé à 20 individus : objectif un modèle espèce sur tous les site de Guyane, 
  -fixé à 0 : objectif modèle multiespèces et multisite.

Nombre minimal de mesure par arbre : 3 pour avoir deux accroissements par arbres et une donnée de mortalité/survie

Année la plus ancienne pour les donnee meteo : d'après les données à disposition

```{r param_etape1, echo=TRUE}
#1 parametres
nbmin_arbres <- 0 # nombre minimal d'individus par espece et par site
nbmin_mes <- 3 # nombre minimal de mesure par arbre
an_min_meteo<- 1968  # donnee meteo les plus anciennes
fich_sauv_circ<-"Data_guyafor_16esp_Clc_join"  # nom du fichier de sortie

# choix des espèces
espGFClim<-c(
  "Bocoa prouacensis",
  "Carapa surinamensis",
  "Chrysophyllum sanguinolentum",
  "Dicorynia guianensis",
  "Eperua falcata",
  "Goupia glabra",
  "Manilkara bidentata",
  "Peltogyne venosa",
  "Qualea rosea",
  "Ruizterania albiflora",
  "Sextonia rubra",
  "Sterculia pruriens",
  "Symphonia globulifera",
  "Virola michelii",
  "Vouacapoua americana",
  "Bagassa guianensis")

# recherche des nom d'espece les plus presents pour les nom vernaculaires
# sort(unique(dispoGuyafor$VernName))
# temp<-dispoGuyafor %>%           # nb individus par espece et par site
#  mutate(idEsp=paste(Genus,Species)) %>%  # ajout colonne ID pour chaque espece
#  filter(VernName=="manil marecage") %>%        #on ne garde qu'un nom vernaculaire
#  group_by(idEsp,idTree) %>%
#  tally %>%
#  filter(n>=3) %>%   # un minimum de 3 mesures par arbre
#  summarise(nbtree = n()) # nb arbre par espece bota

```

##B Chargement des données
 1. Execution DataParacouV6.R : cree la table "dispoGuyafor", 1887076 obs et 31 variables, ou chargement de l'extration de Guyafor DataParacouV6_st.R  1887076 mesures 30 variables

 2. Chargement des données sur le type de traitement par placette et par site
Attention le champs clef est idPlacette absent de la table des données de mesures, issue de DataParacouV6.R

```{r chargement, echo=TRUE}
load("dispoGuyafor2018.Rdata") # contient une table dispoGuyafor

dataDispoLogg<-read.csv2("foret-Campagne.csv") 
ForestLogg<-dataDispoLogg %>% 
   mutate(ForestPlot=paste(NomForet,Libelle)) %>% 
   select(NomForet,Libelle,ForestPlot,idTraitement,Nom)

```


##C Construction de tableau pour la selection des arbres et de leur mesures

###1 Selection espece cible et filtre suivant annee Meteo minimum disponible

```{r F_espces, echo=TRUE}
tabMesures<-dispoGuyafor %>% 
    mutate(idEsp=paste(Genus,Species),codeEsp=paste(substr(Genus,1,3),"_",substr(Species,1,1),sep="")) %>%  # ajout colonne ID pour chaque espece
  filter(idEsp%in%espGFClim) %>%          # on ne garde que les 16 especes cibles
  filter(CensusYear>=an_min_meteo) %>%            # donnee meteo les plus ancienne
  mutate(CDyear=as.numeric(substr(CensusDate,1,4))) %>%  # correction date inventaire par CensusYear
  mutate(CensusD=ifelse(abs(CensusYear-CDyear)>0,paste(CensusYear,substr(CensusDate,5,nchar(CensusDate)),sep=""),CensusDate)) %>% 
  mutate(CensusDate=CensusD) %>% 
  select(-CensusD,-CDyear) %>% 
mutate(NamePlot=paste(Forest,Plot)) %>% # ajout colonne ID pour chaque plot de chaque site
  left_join(ForestLogg, by=c("NamePlot" = "ForestPlot"))  %>% 
      # ajout des colonnes  du tableau ForestLogg pour plot correspondant
  mutate(idForestLoggEsp=paste(Forest,idTraitement,idEsp)) %>% 
     # ajout colonne ID pour chaque traitement de chaque site et chaque espece
  filter(CircCorr>=31.4159) #╦ suppression des arbres de moins de 10 cm

# recherche, nb ligne pour une espèce donnée
#length(tabMesures$idEsp[tabMesures$idEsp=="Bagassa guianensis"])
```
Au final il reste 249645 Mesures

###2 Creation d'une liste des arbres selectionnés
On ne conserve que les arbres avec au moins 3 inventaires. Au final on a 22 545 arbres

```{r l_arbre, echo=TRUE}

tab_arbres<-tabMesures %>%
  group_by(Forest,NamePlot,idTraitement,idEsp,codeEsp,idTree) %>%
  summarise(nbmes = n(),nbvivant=sum(CodeAlive)) %>%
  filter(nbmes>=nbmin_mes) %>%   # un minimum de 3 mesures par arbre  26173obs->22568
  mutate(idForestLoggEsp=paste(Forest,idTraitement,idEsp), Mort=nbmes-nbvivant) %>%  
          # ajout colonne ID pour chaque traitement de chaque site
  select(-nbvivant)
```

###3 Creation liste des site_traitements selectionnés
Pour une espèce on ne conserve un site seulement s'il y a assez d'arbres. Pour rappel, le seuil se gère avec le paramètre "nbmin_arbres"

```{r l_site, echo=TRUE}
tab_esp_site_logg<-tab_arbres %>%
  group_by(Forest,idTraitement,idEsp,codeEsp) %>%
  summarise(nbtree = n(),nbmes_esp=sum(nbmes),nbmort=sum(Mort)) %>%
  filter(nbtree >= nbmin_arbres) %>%    
     # un minimum de nbmin_arbres individu par espece et par site_traitement 259->165
  mutate(idForestLoggEsp=paste(Forest,idTraitement,idEsp)) %>% 
     # ajout colonne ID pour chaque traitement de chaque site
  select(idEsp,codeEsp,idForestLoggEsp,idTraitement,Forest,nbtree,nbmes_esp,nbmort) %>% 
     # mise en forme
  arrange(idEsp,idTraitement)
```


###4 Mise à jour des tables Arbres et Mesures, et création de tableaux résumés
Suppression des arbres correspondant aux sites_traitement n'ayant pas assez d'arbres par espece. Il reste 22545 arbres. Suppression des mesures correspondantes, il reste 243344 mesures
Création d'un tableau de correspondance entre Espèce et code espèce

Remarque : pour nbmin_arbres = 20 *Bagassia guianensis* n'est pas retenue car trop peu d'arbres sont recencés
```{r temp,echo=FALSE}
# tableau pour une espèce donnée
Bagasse<-tab_arbres %>%
  group_by(Forest,idTraitement,idEsp,codeEsp) %>%
  summarise(nbtree = n(),nbmes_esp=sum(nbmes))%>%
  filter(idEsp =="Bagassa guianensis") %>% 
  select(idEsp,codeEsp,Forest,idTraitement,nbtree,nbmes_esp)  # mise en forme

#knitr::kable(Bagasse, caption="Effectif d'arbres et de mesure pour la Bagasse",align=c('r','c','r','c','r','r'))

```

```{r maj_tables, echo=TRUE}
tab_arbres_select<-tab_arbres%>%  
      # on enleve de la table "arbres" les individus qui ne sont pas assez nombreux
  semi_join(tab_esp_site_logg, by=c("idForestLoggEsp"))
# le semi_joint n'ajoute pas les colonne du second tableau 
# et supprime les lignes du premier tableau qui ne matchent pas

tabMesuresSelect<-tabMesures%>%   # on enleve de la table mesure les individus non retenus
  semi_join(tab_arbres_select,by=c("idTree"))


#creation de tables descriptives des donnes, par site, par especes
tab_site_logg<-tab_esp_site_logg %>%      # tableau site, type traitement : nbesp, arbres et mesures
 group_by(Forest,idTraitement) %>%
 #arrange(idForestLoggEsp) %>%
 summarise(nbesp = n(),nbtree_logg=sum(nbtree),nbmes_logg=sum(nbmes_esp),nbmort_logg=sum(nbmort)) %>%
 select(idTraitement,Forest,nbesp,nbtree_logg,nbmes_logg,nbmort_logg) # mise en forme

tab_esp<-tab_esp_site_logg %>%    # tableau espece, type traitement : nbsitelogg, arbres et mesures
  group_by(idEsp,codeEsp,idTraitement) %>%
  summarise(nbsitelogg = n(),nbtree_esp=sum(nbtree),nbmes_esp=sum(nbmes_esp),nbmort_esp=sum(nbmort)) 

# controle : 193934 obs
#sum(tab_esp_site_logg$nbmes_esp)
#sum(tab_arbres_select$nbmes)
#nrow(tabMesuresSelect)

# construction tableau espèce et code espece explicite pour sortie fichier, graphe
cc_espGFClim<-tabMesuresSelect %>% 
  select(idEsp,codeEsp) %>% 
  group_by(idEsp,codeEsp) %>% 
  summarise() %>% 
  arrange(idEsp)
```

```{r tableau_eff,echo=TRUE}
knitr::kable(tab_esp, caption="Effectif d'arbres et de mesure par espèce et traitement",align=c('r','c','r','c','c','r','r'))
```
##D Conversion des circonférence en diamètre et régularisation pour les nouveaux morts
L'année du constat de la mort d'un individu, on remplace les circonferences des arbres mort par NA sinon on calcule le diametre

```{r cirr_to_diam, echo=TRUE}
tabMesuresSelect<-tabMesuresSelect %>%
  mutate(Diam = if_else(CodeAlive == 1, CircCorr/pi, NA_real_))
```


##E Calcul du paramètre Dmax 
Nécessaire dans le modèle de mortalité pour normaliser le diamètre initial et le transformer en une variable d'ontogénie.
Pratiquement on ne calcul pas le dmax qui est trop volatile, mais le percentile 95. Pour 20 donnée cela correspond à la 2ième plus grande.
Pour les site où le nombre d'individu est inférieur à 20, on prend le dmax calculé sur les arbres de tous les sites

Une colonne Dmax95 est ajoutée aux tableaux, esp_site et mesures.

Remarque : on peut noter que,  par exemple pour Dicorynia, le dmax varie de manière importante entre sites. Cela peut avoir une importance dans le modèle de croissance. Si on utilise un Dmax "régional"", certains sites n'auront que des individus à un stade ontogénétique "jeune".

```{r dmax, echo=FALSE}
seuil<-15 # nombre de mesure minimal pour valider le calcul du dmax par site

Dmax_esp<-tabMesuresSelect %>%           
  group_by(idEsp,codeEsp,idTree) %>%
  summarise(DmaxTree = max(Diam)) %>%  
      # on réduit à une ligne par arbre et on garde la circonference max de chaque arbre
  group_by(idEsp,codeEsp) %>%
  summarise(nbtree=n(),Dmax95_esp=quantile(DmaxTree,0.95,na.rm=TRUE)) %>%  # calcul percentile95 par expece multisite
  select(idEsp,Dmax95_esp)  #mise en forme


Dmax_esp_site<-tabMesuresSelect %>%           
  group_by(Forest,idEsp,codeEsp,idTree) %>%
  summarise(DmaxTree = max(Diam)) %>%  
      # on réduit à un ligne par arbre et on garde la circonference max de chaque arbres
  group_by(Forest,idEsp,codeEsp) %>%
  summarise(nbtree=n(),Dmax95=quantile(DmaxTree,0.95,na.rm=TRUE)) %>% # calcul Dmax95 par espece et par site  
  select(idEsp,codeEsp,Forest,Dmax95,nbtree) %>% #mise en forme
  arrange(idEsp,Dmax95) %>% 
  left_join(Dmax_esp,by=c("idEsp")) %>% 
  mutate(Dmax95 = if_else(nbtree >= seuil, Dmax95, Dmax95_esp)) %>% # si nb arbres par site trop faible on attribue le dmax de l'espèce multisite
  select(-Dmax95_esp)
  
  

# calcul de l'amplitude des dmax pour chaque espece et ajout des Dmax par site#
esp_range_dmax<-Dmax_esp_site %>%
  group_by(idEsp,codeEsp) %>%
  summarize(Dmax_h=max(Dmax95),Dmax_b=min(Dmax95))

tabMesuresSelect<-tabMesuresSelect %>%
  left_join(select(Dmax_esp_site,-nbtree), by=c("idEsp","codeEsp","Forest"))

tab_esp_site_logg<-tab_esp_site_logg %>% 
  left_join(select(Dmax_esp_site,-nbtree), by=c("idEsp","codeEsp","Forest")) %>%
  rename(Dmax95Forest=Dmax95)
```

```{r tableaux_dmax, echo=FALSE}
#knitr::kable(esp_range_dmax, digits= 1,caption="Min et Max de Dmax95 par espèce",align=c('r','c','r','r'))
#knitr::kable(Dmax_esp_site, digits= 1,caption="Dmax95 par espèces et par site",align=c('r','c','c','r','r'))

```


##F Construction des tableaux de données
Les données pour le modèle sont sous forme de tableau de donnees BIANNUELLES i.e. pour le modèle de croissance une observation est un accroissement entre deux dates d'inventaire, pour le modèle de mortalité une observatiosn est un etat vivant ou mort une année n et les diamètres de l'année n-1 et n-2

```{r 2ans_data, echo=TRUE}

## Construction donnees pour modele d'accroissement

datacr_sc<-tabMesuresSelect%>%
 # slice(1:20)%>%
  arrange(idTree,CensusYear)%>%     # on trie par arbre et annee
  select(idTree,idEsp,codeEsp,Diam,CodeAlive,CensusYear,CensusDate,Dmax95,Forest,Plot,idTraitement)%>%    # choix de quelques colonnes
  mutate(Diam2=lead(Diam),CodeAlive2=lead(CodeAlive),idTree2=lead(idTree),Year2=lead(CensusYear),CDate2=lead(CensusDate))%>% # decalage des donnes diametre et annee
  filter(idTree==idTree2)%>%  # on ne garde que les ligne qui concerne le meme individu
  filter(CodeAlive2==TRUE & CodeAlive==TRUE)%>% # on ne garde que  les ligne avec "mesure" sur arbre vivants
  select(idTree,idEsp,codeEsp,Diam1=Diam,Diam2,Year1=CensusYear,Year2,CDate1=CensusDate,CDate2,Dmax95,Forest,Plot,idLogg=idTraitement)%>% # mise en forme
  mutate(AGR=(Diam2-Diam1)/(Year2-Year1)) %>%  # calcul des acroissements
  filter(AGR>=0) %>% # on suprimme les accroisssements negatifs
  arrange(idTree,Year1)     # on trie par arbre et annee
  

## Construction fichier pour modele mortalite

datamo_sc<-tabMesuresSelect%>%
  arrange(idTree,CensusYear)%>%   # on trie par arbre et annee
  select(idTree,idEsp,Diam,CodeAlive,CensusYear,CensusDate,Dmax95,Forest,Plot,idTraitement)%>%  # choix de quelques colonnes
    # decalage vers le haut des colonnes diametre (-1), codeAlive (-2), pour creer des champs pour l'acroissement et le champs vivant/mort
  mutate(Diam2=lead(Diam),CodeAlive3=lead(CodeAlive,2),idTree3=lead(idTree,2),Year2=lead(CensusYear),Year3=lead(CensusYear,2),CDate2=lead(CensusDate),CDate3=lead(CensusDate,2))%>% 
  filter(idTree==idTree3)%>%    # on enleve les lignes qui avec des donnees de deux individus differents
  select(idTree,idEsp,Diam1=Diam,Diam2,CodeAlive3,Year1=CensusYear,Year2,Year3,CDate1=CensusDate,CDate2,CDate3,Dmax95,Forest,Plot,idLogg=idTraitement)%>% # quelques nouveaux titres de colonne"
    # le diametre d'interet pour le modele demortalite est en n-1 avant l'evenement de mort ou de survie, creation to_death ( 1 = deces, 0= survie)
  mutate(AGR=(Diam2-Diam1)/(Year2-Year1),rdiam=Diam2/Dmax95,to_Death=if_else(CodeAlive3,0,1)) %>% 
  filter(AGR>=0) %>% # on suprimme les accroisssements negatifs
  arrange(idTree,Year1)   # on trie par arbre et annee


#controle : Water0 doit être vide
Water0<-datamo_sc %>% 
  mutate(duree=Year3-Year1) %>% 
  filter(duree<=0)


```


# 2 Création de l'indice de stress hydrique

## Démarche générale sur l'utilisation des données climat (pluviométrie) 
A partir de donnée pluviométrie et de données sur des caractéristiques physiques du sol et de son fonctionnement hydrique, il est possible de calculé un indice journalier de disponibilité en eau du sol pour les arbres : le REW (Relative Extractable Water, cit. Wargner et al 2011). Un REW de 1 correspond à une disponibilité maximale, une valeur de 0 à un absence totale de disponibilité en eau. En dessous d'un REW de 0.4 on considère que les arbres souffrent de stress hydrique.
Le calcul des REW journalier est fait par le doc "prepa_donnee/Climat/REW_gfclim/Donnees_climat_pre-traitement.Rmd"

Il est alors possible de construire un indice de stress hydrique sur des durées supra-journalière (semaine, mois, années) en sommant, uniquement pour les journées avec un REW inférieur à 0.4, les écart entre le REW observé et le seuil de 0.4. Sur un graphique montrant l'évolution journalière du REW, cet indice correspond à l'aire "vide" sous la droite REW=0.4 (cit Aubry-Kientz et al 2015)

Pour cette étude nous avons à notre disposition des données sols pour le site de Paracou et des données pluviométriques pour la plupart des sites Guyafor. Nous allons donc construire un indice de stress hydrique pour chaque site Guyafor avec sa pluviométrie, mais en conservant les données sol de Paracou.

La construction de la covariable climat se fait en deux étapes

1. calcul d'un indice de stress interinventaire par site et par parcelle. La date d'inventaire, au mois prés,est prise en compte dans les paramètres. l'indice est ramené à un indice annuel, en fonction les durée inter-inventaires

2. pour chaque ligne de donnée (accroissement ou évènement de survie/mortalité), calcul et ajout de la covariable climat qui depend de la date initiale, de la date finale et du site.


## Calcul Indice Stress hydrique inter-inventaire (au mois près)
Paramètres : le seuil pour le calcul de l'indice journalier des tress hydrique (WS) (ici, 0.4)

Données :
  1. le fichier de donnée de circonférence issu de l'étape 1
  2. le table de donée des REW journaliers (colonnes : Forest, REW, year, month, day)

```{r climat, echo=TRUE}

# paramètres
seuilREW<-0.4  # seuil pour calcul indice Water

# test sur Paracou
# fich_clim_forest<-"Paracou_clim.Rdata"
# REWdata<-read.csv2("REW_1978-2017_Fabien.csv",sep=",",dec=".")


# chargement des donnée REW par jour et par site (donnees journalières de REW avec date en trois colonnes : year, month, day)

load(file="REW_guyafor_multisite.Rdata")
     # station, # plages de dates des donnée par station meteo
     # site_station,# tableau des correspondance entre site Guyafor (Forest) et stations meteo
     # REW_sites_gfclim,# REW par date et par site (Forest)
     # tab_pluvio_na,           # effectif de donnee pluvio manquante par plage de temps et par dispositifs
     # REW_Guyafor,            # données REW sur station météo utile pour Guyafor 


ISHdata<-REW_sites_gfclim %>% 
  # mutate(Forest="Paracou") %>% 
  mutate(Ish=if_else(seuilREW-REW>=0,seuilREW-REW,0)) %>% 
  group_by(Forest,year,month) %>% 
  summarise(Ishm=sum(Ish)) %>% 
  ungroup() %>% 
  mutate(CDymIsh=paste(year,"-",month,"-15",sep="")) %>% 
  transmute(Forest=Forest, Ishm=Ishm, CDymIsh=as.Date(CDymIsh,"%Y-%m-%d"))

# ableau min_max par site
dispoMinMaxIshDate<-ISHdata %>% 
  group_by(Forest) %>% 
  summarise(MinCDclim=min(CDymIsh),MaxCDclim=max(CDymIsh))


# Construction d'un tableau des sites et couples d'inventaire à partir des mesures sélectionnées

# assemblage avec les couples d'inventaires des donnees de croissance et suppression des doublon
  tempmo<-datamo_sc %>%  #  extraction des couples de date d'inventaire des donnees de mortalite
  select(Forest,CDate2,CDate3) %>% 
  rename(Forest=Forest,CDate1=CDate2,CDate2=CDate3) %>% 
  bind_rows(select(datamo_sc,Forest,CDate1,CDate2))
  

ForestInvIsh<-datacr_sc %>%  
  select(Forest,CDate1,CDate2) %>% 
  bind_rows(tempmo) %>% 
  distinct() %>% 
  mutate(CDate1=as.Date(CDate1,"%Y-%m-%d"),CDate2=as.Date(CDate2,"%Y-%m-%d")) %>% # Passe les Cdate en format date
  mutate(CDym1=paste(format(CDate1,format = "%Y"),"-",format(CDate1,format =  "%m"),sep="")) %>%  
  mutate(CDym2=paste(format(CDate2,format="%Y"),"-",format(CDate2,format = "%m"),sep="")) %>% # selectionne seulement les mois et année pour diminuer les nombres d'inventaires
  select(Forest,CDym1,CDym2) %>% 
  distinct() %>% 
  transmute(Forest=Forest,CDym1=as.Date(paste(CDym1,"-15",sep=""),"%Y-%m-%d"),CDym2=as.Date(paste(CDym2,"-15",sep=""),"%Y-%m-%d")) %>% # Passe les Cdate en format date, on ajoute un nombre pour le jour sinon as.Date renvoi NA
  mutate(IshInv=NA) # on crée une colonne vide pour l'indice de stress hydrique



# tableau date min d'inventaire par site
dispoMinMaxCensusDate<-ForestInvIsh %>% 
  group_by(Forest) %>% 
  summarise(MinCD=min(CDym1),MaxCD=max(CDym2)) %>% 
  left_join(dispoMinMaxIshDate, by="Forest") %>% 
  mutate(pbdate=ifelse((MinCD>=MinCDclim)&(MaxCD<=MaxCDclim),"ok",
                       ifelse((MinCD<MinCDclim)&(MaxCD<=MaxCDclim),"pb Min",
                              ifelse((MinCD>=MinCDclim)&(MaxCD>MaxCDclim),"pb Max","pb Min et Max"))))
write.csv2(dispoMinMaxCensusDate,file="dispoMinMaxCensusdate.csv")

# test sur Paracou
# ParacouInvIsh<-ForestInvIsh %>% filter(Forest=="Paracou") #%>% 
# mutate(ISHmy=ISH(CDym1,CDym2,Forest,dataREW))


# boucle de calcul de l'indice pour chaque ligne foret_couple_inventaire
# temps_depart <-Sys.time()
# i<-612
for(i in 1:nrow(ForestInvIsh)) {
  Fplot<-ForestInvIsh$Forest[i]
  date1<-ForestInvIsh$CDym1[i]
  date2<-ForestInvIsh$CDym2[i]
  
  testdate<-date1%in%ISHdata$CDymIsh[ISHdata$Forest==Fplot] & date2%in%ISHdata$CDymIsh[ISHdata$Forest==Fplot] # test inter-inventaire couvert par donnees clim
  sortie<-ISHdata %>% filter(Forest==Fplot & (CDymIsh >= date1) & (CDymIsh < date2))  
  ForestInvIsh$IshInv[i]<-ifelse(testdate,sum(sortie$Ishm)/as.numeric(date2-date1)*365,NA) # on ramène l'indice de stress hydrique à un indice annuel, comme pour les accroissemnents en diamètre
  }
# Sys.time()-temps_depart
# test<-ForestInvIsh %>% 
#   filter(is.na(IshInv)) %>% 
#   group_by(Forest) %>% 
#   summarise(nbinv=n())

```


## Ajout des variables climat au tableaux de données

```{r climat_index_ajout, echo=TRUE}
datacr_cl<-datacr_sc %>%
  mutate(CDym1=as.Date(CDate1,"%Y-%m-%d"),CDym2=as.Date(CDate2,"%Y-%m-%d")) %>% 
  # Passe les Cdate en format date
  mutate(Datetemp1=paste(format(CDym1,format = "%Y"),"-",format(CDym1,format =  "%m"),sep="")) %>%  
  mutate(Datetemp2=paste(format(CDym2,format="%Y"),"-",format(CDym2,format = "%m"),sep="")) %>% 
  mutate(CDym1=as.Date(paste(Datetemp1,"-15",sep=""),"%Y-%m-%d"),CDym2=as.Date(paste(Datetemp2,"-15",sep=""),"%Y-%m-%d")) %>% 
  # on ajoute un nombre pour le jour sinon as.Date renvoi NA
  select(-Datetemp1,-Datetemp2) %>% 
  left_join(ForestInvIsh,by=c("Forest","CDym1","CDym2")) %>% 
  filter(!is.na(IshInv))  
 
datamo_cl_tmp<-datamo_sc %>%
  mutate(CDym1=as.Date(CDate1,"%Y-%m-%d"),CDym2=as.Date(CDate2,"%Y-%m-%d"),CDym3=as.Date(CDate3,"%Y-%m-%d")) %>% # Passe les Cdate en format date
  mutate(Datetemp1=paste(format(CDym1,format = "%Y"),"-",format(CDym1,format =  "%m"),sep="")) %>%  
  mutate(Datetemp2=paste(format(CDym2,format="%Y"),"-",format(CDym2,format = "%m"),sep="")) %>% 
  mutate(Datetemp3=paste(format(CDym3,format="%Y"),"-",format(CDym3,format = "%m"),sep="")) %>% 
  mutate(CDym1=as.Date(paste(Datetemp1,"-15",sep=""),"%Y-%m-%d"),CDym2=as.Date(paste(Datetemp2,"-15",sep=""),"%Y-%m-%d"),CDym3=as.Date(paste(Datetemp3,"-15",sep=""),"%Y-%m-%d")) %>% # on ajoute un nombre pour le jour sinon as.Date renvoi NA
  select(-Datetemp1,-Datetemp2,-Datetemp3) %>% 
  left_join(ForestInvIsh,by=c("Forest","CDym1","CDym2")) %>% 
  rename(IshInvVig=IshInv) %>% 
  filter(!is.na(IshInvVig)) 

ForestInvIsh_mo<-ForestInvIsh %>% 
  rename(CDym3=CDym2) %>% 
  rename(CDym2=CDym1) 

datamo_cl<- datamo_cl_tmp %>% 
  left_join(ForestInvIsh_mo,by=c("Forest","CDym2","CDym3")) %>% 
  rename(IshInvMo=IshInv) %>%  
  filter(!is.na(IshInvMo))

  
save(datacr_cl,datamo_cl,file="data_WaterStress_guyafor.rdata") # le 17/01/2020, le29/02/2020 après correction des CensusDate et pb datemin et date max d'inventaire



```


# 3 Calcul des indices de perturbation pour les parcelles exploitées.
L'indice de perturbation est le pourcentage de biomasse enlevée ou morte, lors de l'exploitation, par rapport à la biomasse initiale de la parcelle.
La valeur initiale est donnée par l'inventaire le plus récent avant exploitation, la valeur post exploitation est donnée par un inventaire quelques année après exploitation afin de prendre en compte l'effet retard de l'exploitation sur la mortalité des arbres.
Ce délai est le paramètre YaLogg (Year after Logging). D'après les résulats de Camila Piponio-Laroche, ce temps de latence est autour de 5 ans.
la valeur de biomasse post exploitation sera donnée par l'inventaire post-exploitation, le plus proche de : année d'exploitation + YaLogg.

Une fois les année de mesures selectionnées, on fait le calcul sur les mesures corrrespondantes de Guyafor, en utilisant le package BIOMASS

Seuls les dispositifs de Paracou, Montagne Tortue et Manaré, ont de vrais inventaire pré-exploitation. 
Pour le BAFOG l'inventaire a été fait au mieux 26 ans après exploitation.
Pour les parcelles Organabo et Risquetout le premier inventaire a eu lieu au mieux 8 ans après l'exploitation. Sur ces parcelles exploitée, la moitiée des parcelles ont été éclaircies et d'autres sont restées en temoins, c'est à ditre exploitées mais pas eclaircies. D'après l'ONf, la parcelle Risquetout 8 a été très peu exploité (absence totale de souches). Nous tenterons de la prendre comme référence de biomasse pré-exploitation pour les parcelles de Risquetout.

## A Choix des années d'inventaire pré et post exploitation quand elles existent
```{r perturbation_select_year, echo=TRUE}
# on repart des données Guyafor de base sur les parcelle exploitées et du fichier sur les données dispositifs
#load("dispoGuyafor2018.Rdata") # contient une table dispoGuyafor

# Parametrage
YaLogg <- 4.6  # avec décimale <> 0.5 pour éviter le problème de inventaire tout les deux ans ou tout les ans

dataDispoLogg<-read.csv2("foret-Campagne.csv") # extraction de la base Guyafor, contient les effectifs de mesures par dates de fin d'inventaire et info sur type et année d'exploitation

# Création d'un tableau du nombre de mesure par Forest/parcelle/date_inventaire
ForestInv<-dataDispoLogg %>% 
  select(NomForet, Libelle,Surface,idTraitement,DateExploitation,starts_with("inv")) %>% 
  gather(starts_with("inv"), key=DateInvt, value=Nbmes) %>% 
  filter(!is.na(Nbmes)) %>% 
  arrange(NomForet, Libelle) %>% 
  mutate(CensusDate=as.Date(substr(DateInvt,4,14),"%d_%m_%Y")) %>% #mise au format date de la colonne DateInv
  mutate(CensusYear=as.numeric(substr(DateInvt,10,14))) %>%    # extraction année d'inventaire
  select(-DateInvt)

# check les année/parcelle pour lesquelles il y a deux dates d'inventaire : pas mal de parecelle/année à Paracou, 2 à risquetout et deux à Organabo 
# control<-ForestInv %>% 
#  group_by(NomForet, Libelle,idTraitement,DateExploitation,CensusYear) %>% 
#  summarise(nbinv=n()) %>% 
#  filter(nbinv>1)
# write.table(control,file="deux_inv_paracou.csv",sep=";")

# cumul des donnée si plusieurs inventaire de la même parcelle la même année : attention P9 paracou annéee à 11000 individus : surement des juvéniles
ForestInv<-ForestInv %>% 
  group_by (NomForet,Libelle,Surface,idTraitement,DateExploitation,CensusYear) %>% 
  summarise (Nbmes=sum(Nbmes))

# Selection des inventaires les plus proches des désirata en pre et post exploitation
temp_LI<-ForestInv %>%          
  filter((idTraitement>0) & (!is.na(DateExploitation))) %>% # selection des parcelles avec traitement
  mutate(temp1=CensusYear-DateExploitation) %>% 
  mutate(PrePost=if_else(temp1>=0,"post","pre")) %>% 
  mutate(temp2=if_else(PrePost=="post",temp1-YaLogg,temp1)) %>% # calcul des dif en année entre inventaire et date d'exploitation
  mutate(temp2=abs(temp2)) %>% 
  group_by(NomForet,Libelle,PrePost) %>% 
  mutate(temp3=min(temp2)) %>% 
  filter(temp3==temp2) %>% 
  arrange(NomForet,Libelle,desc(PrePost)) %>% 
  select(-starts_with("temp"))

# verif nb inv pré et post par parcelle 
control_ni<-temp_LI %>% 
  group_by(NomForet,Libelle, PrePost) %>% 
  summarise(nbtest=n())
 
temp_LI_1<-temp_LI %>% 
  select(-Nbmes) %>% 
  spread(key=PrePost,value=CensusYear) %>% 
  rename(Pre_CY=pre,Post_CY=post)

DispoLogg<-temp_LI %>% 
select(-CensusYear) %>% 
spread(key=PrePost,value=Nbmes) %>% 
rename(Pre_nbmes=pre,Post_nbmes=post)  %>% 
inner_join(temp_LI_1,by=c("NomForet","Libelle","Surface","idTraitement","DateExploitation")) %>% 
select(NomForet,Libelle,Surface,idTraitement,DateExploitation,Pre_CY,Post_CY,Pre_nbmes,Post_nbmes)%>% 
mutate(ForestPlot=paste(NomForet, Libelle)) %>%
filter((!is.na(Pre_CY)&!is.na(Post_CY))|(NomForet %in% c("Organabo","Risquetout")))

```
```{r tableaux_site_pre_post_logg, echo=FALSE}
knitr::kable(DispoLogg, digits= 1,caption="Disositif et année d'inventaire pré et post exploitation",align=c('l','l','c','c','c','c','c','l'))

```

## B Calcul de l'indice par parcelle avec inventaire pré-exploitation
On utlise le Package "BIOMASS". La fonction de calcul de la biomasse, prend en entrée un genre, une espèce, un diamètre et une position en longitude et lattitude.

```{r perturbation_index, echo=TRUE,message=FALSE,warning=FALSE}
#selection des mesures cibles pre et post exploitation
index_trait_mes<-dispoGuyafor %>% 
  select(Forest, Plot,idTree,Genus,Species,CensusYear,CodeAlive,CodeMeas,CircCorr,Lon,Lat) %>% 
  filter(CodeAlive==TRUE & CircCorr>=31.4) %>% 
  mutate(ForestPlot=paste(Forest, Plot)) %>% 
  semi_join(DispoLogg, by="ForestPlot") %>%        # selection des mesures d'individus sur les parcelles correspondantes
  left_join(DispoLogg,by="ForestPlot") %>%           # import colonne table dispositif dont année pré-et post-exploitation
  select(-NomForet,-Libelle) %>% 
  filter((CensusYear==Pre_CY) | (CensusYear==Post_CY)|(Forest %in% c("Organabo","Risquetout"))) %>% 
  mutate(GS=paste(as.character(Genus),"_",as.character(Species)))


# verification des genre et espèce et import des WD
liste_esp<-index_trait_mes %>% #creation d'une liste unique d'espèce
  select(Genus,Species,GS) %>% 
  distinct() %>% 
  mutate(idEsp=paste(as.character(Genus),as.character(Species))) # attention insere un espace entre les deux champs

Taxo=correctTaxo(genus=as.character(liste_esp$Genus), species=as.character(liste_esp$Species)) # correction des noms d'especes

#WDdata=getWoodDensity(genus=Taxo$genusCorrected, species=Taxo$speciesCorrected, stand=Data$Plot) # get WD (mean and sd), l'option stand permet d'attribuer la WD moyenne pour les espèces inconnues, mais demeande de faire le calcul pour chaque arbres (sur table index_trait)
WDdata=getWoodDensity(genus=Taxo$genusCorrected, species=Taxo$speciesCorrected) # donne WD du genre si espece inconnu ou de l'ensemble des donnees si genre inconnu. Pas de prise en compte de la famille
liste_esp<-cbind(liste_esp,WDdata)

#import des WD pour chaque mesure et calcul de l'AGB par placette et année
index_trait<-index_trait_mes %>% 
  select(-Genus,-Species) %>% 
  left_join(liste_esp,by="GS") %>% 
  select(-genus,-species) %>% 
  mutate(DBH=CircCorr/pi) %>% 
  mutate(AGB=computeAGB(D=DBH, WD=meanWD, coord = cbind(Lon,Lat))) %>%
  filter(!is.na(Pre_CY)&!is.na(Post_CY)) %>%    # pour retirer les forêt de Risquetout et Organabo
  mutate(T_index=if_else((CensusYear==Pre_CY),"PreLogg","PostLogg")) %>%  # pour garder le type d'année
  group_by(ForestPlot,Surface,CensusYear,T_index) %>% 
  summarise(AGB_plot=sum(AGB)) %>%    # calcul de la biomasse par dispositif
  ungroup() %>%       # on dégroupe pour pouvoir supprimer l'année d'inventaire qui empecherait de faire le spread
  select(-CensusYear) %>% 
  spread(key=T_index, value=AGB_plot) %>%   # on crée des colonnes à partir de T_index et on y place les valeur de AGB
  filter((!is.na(PreLogg))&(!is.na(PostLogg))) %>%  # on supprime les dispositifs avec une seule date
  mutate(IndexLogg=(1-PostLogg/PreLogg)*100)                 
 
# hist(index_trait$AGB)
# max(index_trait$AGB)
# temp<-index_trait %>% filter(AGB>=25)
# hist(temp$AGB)
```

## C Tentative d'ajout indice pour Risquetout et Organabo (non concluant)
Sur les parcelle de Risquetout exploitation en 1983, premier inventaire en 1999, éclaircie des parcelles en 
  P05 exploitation 1983, traitée en 1995, inventoriée en 1995
  P08 exploitation 1983, traitée en 1998, inventoriée en 1999
  P14 exploitation 1983,traité en 2000, inventoriée en 2001, 2004

Sur les parcelle d'organabo  
  P06 exploitation en 1986, traité en 1996, premier inventaire 1997
  P09 exploitation en 1991, traitée en 1998, premier inventaire 1999
  P10 exploitation en 1991, traité en 2000, premier inventaire 2000
  
La P8 de Risquetout est connue por avoir très peu de souche et donc ne pas avoir été trop impactée par la première exploitation.
  
```{r perturbation_risquetout, echo=FALSE}
# calcul biomasse parcelle et par année d'inventaire

index_rqt<-dispoGuyafor %>% 
  filter(CodeAlive==TRUE & CircCorr>=31.4 & (Forest %in% c("Risquetout","Organabo"))) %>% 
 # filter((Plot=="P08 témoin") | (Plot=="P08 traitée")) %>% 
  select(Forest, Plot,PlotSurface,idTree,Genus,Species,CensusYear,CodeAlive,CodeMeas,CircCorr,Lon,Lat) %>% 
  mutate(ForestPlot=paste(Forest, Plot)) %>% 
  mutate(GS=paste(as.character(Genus),"_",as.character(Species))) %>% 
  mutate(DBH=CircCorr/pi) %>% 
  select(-Genus,-Species) %>% 
  left_join(liste_esp,by="GS") %>% 
  select(-genus,-species) %>% 
  mutate(AGB=computeAGB(D=DBH, WD=meanWD, coord = cbind(Lon,Lat))) %>%
  group_by(Forest,ForestPlot,PlotSurface,CensusYear) %>%  
  summarise(AGB_plot_year=sum(AGB)) %>%  # calcul de la biomasse par parcelle et année
  mutate(AGB_ha=AGB_plot_year/PlotSurface) %>% 
  select(-AGB_plot_year) %>% 
  spread(key=CensusYear, value=AGB_ha) # on crée des colonnes à partir de CensusYear et on y place les valeur de Biomasse

table_rqt<-index_rqt %>% 
  filter(Forest=="Risquetout") %>% 
  select(-"2000",-"2007",-"2013") %>% 
  select(-PlotSurface)
  
knitr::kable(table_rqt, caption="Biomasse Risquetout")

```
Conclusion les AGB sur Risquetout et Organabo sont super variables dans le temps y compris sur les parcelles témoins et sur la parcelle 8 qui est la moins "exploitée". Par ailleurs la parcelle "temoin" P14 à une biomasse 1/3 supérieure à celle de la P8.
Leur utilisation dans le modèle est donc très délicate

Au final on ne conserve que 13 pareclles sur 3 sites pour les données d'exploitation. Les parcelles de Risquetout et Organabo doivent être retiré de l'analyse pour ne pas d'être considérée comme parcelle non exploitées, de mêem que le sparcelle exploitée du BAFOG.

## D Ajout indice traitement et WD aux tableaux de données croissance et mortalité
  
```{r perturbation_index_ajout, echo=TRUE}
# parcele xploitée mais sans calcul d'indice passible
PLogg_sans_index<-c("BAFOG II","BAFOG III","BAFOG IV")
Flogg_sans_index<-c("Organabo","Risquetout")

#Ajout WD au tableau des especes
cc_espGFClim <-cc_espGFClim %>% 
  left_join(select(liste_esp,idEsp,meanWD),by="idEsp") %>% 
  rename(WD=meanWD)

  
 # données pour le modèle de croissance
datacr_cl_lo<-datacr_cl %>% 
  filter(!Forest %in% Flogg_sans_index) %>% 
  mutate(ForestPlot=paste(Forest, Plot)) %>%  # suppression de forêts exploitées mais sans indice Logg
  left_join(index_trait,by="ForestPlot") %>%  # ajout des indices traitement
  filter(!ForestPlot %in% PLogg_sans_index) %>% # suppression des parcelles exploitées mais sans indice Logg
  mutate(TxLogg=if_else(is.na(IndexLogg),1,IndexLogg)) %>% 
  left_join(select(cc_espGFClim,idEsp,WD),by="idEsp") # ajout des WD
  
  
# données pour le modèlede mortalité
datamo_cl_lo<-datamo_cl %>% 
  filter(!Forest %in% Flogg_sans_index) %>% 
  mutate(ForestPlot=paste(Forest, Plot)) %>% 
  left_join(index_trait,by="ForestPlot") %>%    
  filter(!ForestPlot %in% PLogg_sans_index) %>% 
  mutate(TxLogg=if_else(is.na(IndexLogg),1,IndexLogg)) %>% 
  left_join(select(cc_espGFClim,idEsp,WD),by="idEsp") # ajout des WD


```


# 4 Sauvegarde des tableaux de données

```{r sortie,echo=TRUE}
save(nbmin_arbres,            # nombre minimal d'arbres par esp et par site
     nbmin_mes,               # nombre minimal de mesures par arbres
     an_min_meteo,            # donnee meteo les plus anciennes
     tabMesuresSelect,        # table de données
     tab_arbres_select,       # Id et statu des arbres sélectionnés
     tab_esp,                 # effectif de d'arbre et de mesure par esp et par traitement 
     tab_esp_site_logg,       # effectif d'arbres et mesure par esp, par site et par traitement
     tab_site_logg,           # effectif d'arbres et mesures par site, par traitement et par espèce
     esp_range_dmax,          # Min et max des dmax95 par espèce
     espGFClim,               # liste des especes cibles
     Dmax_esp_site,           # dmax par espèce et par site
     cc_espGFClim,            # correspondance espèce et code-espèce
     ForestInvIsh,           # valeur indice stress hydrique par forest et par int. d'inventaire
     index_trait,              # valeur indice exploitation par site
     datacr_cl_lo,            # données pour le modèle de croissance
     datamo_cl_lo,            # données pour le modèlede mortalité
     file=paste(fich_sauv_circ,".Rdata",sep="")) #Data_guyafor_16esp_Clc_join.Rdata fichier avec donnée climat multisite, cavec date corrigées
#Data_guyafor_16esp_Cl_join.Rdata fichier avec donnée climat multisite
#"Data16esp_s0_to_join.Rdata") #"S0" pour seuil à 0 pour le nb minimal d'arbres par esp et par site, le 12/06/2019, avec le % de biomasse perdue sur IndexLogg

# pour export vers Rstudio reseau
save(nbmin_arbres,            # nombre minimal d'arbres par esp et par site
     nbmin_mes,               # nombre minimal de mesures par arbres
     an_min_meteo,            # donnee meteo les plus anciennes
     tabMesuresSelect,        # table de données
     tab_arbres_select,       # Id et statu des arbres sélectionnés
     tab_esp,                 # effectif de d'arbre et de mesure par esp et par traitement 
     tab_esp_site_logg,       # effectif d'arbres et mesure par esp, par site et par traitement
     tab_site_logg,           # effectif d'arbres et mesures par site, par traitement et par espèce
     esp_range_dmax,          # Min et max des dmax95 par espèce
     Dmax_esp_site,           # dmax par espèce et par site
     cc_espGFClim,            # correspondance espèce et code-espèce
     ForestInvIsh,           # valeur indice stress hydrique par forest et par int. d'inventaire
     index_trait,              # valeur indice exploitation par site
     datacr_cl_lo,            # données pour le modèle de croissance
     datamo_cl_lo,            # données pour le modèlede mortalité
     file=paste(fich_sauv_circ,"2.Rdata",sep=""),version=2) 
```


```{r debug_data,echo=FALSE,warning=FALSE,message=FALSE}
#5 Debugages
# temp<-datamo_cl_lo %>% 
#   filter(is.na(IshInvMo)) %>% 
#   filter(Forest=="Paracou") %>% 
#   group_by(Forest,CDate2,CDate3,CDym2,CDym3) %>% 
#   summarise()
# temp2<-datamo_cl_lo %>% 
#   filter(Forest=="Paracou") %>% 
#   group_by(Forest,CDym1,CDym2,IshInvVig) %>% 
#   summarise() %>% 
#   rename(CDym2=CDym1,CDym3=CDym2) %>% 
#   semi_join(temp,by=c("CDym2","CDym3"))
# save(temp,file="pb_clim_paracou _plot.RData")
# 
# temp<-datamo_cl_lo
# min(temp$IndexLogg, na.rm=TRUE)
# max(temp$IndexLogg,na.rm=T)
# median(temp$IndexLogg,na.rm=T)
# hist(temp$IshInvVig)
# hist(temp$TxLogg)
# SHcr<-(temp$IshInvVig-mean(temp$IshInvVig,na.rm=T))/sd(temp$IshInvVig,na.rm=T)
# hist(SHcr)
# Loggcr<-(temp$TxLogg-mean(temp$TxLogg,na.rm=T))/sd(temp$TxLogg,na.rm=T)
# hist(Loggcr)

clim_nouragues<-REW_sites_gfclim %>% 
  filter(Forest=="Nouragues")  
  
ggplot(clim_nouragues)+
  geom_line(aes(x=day_julian, y=REW))+
  facet_wrap(~year,scale="free")


par(mfrow=c(2,3))
 hist(datamo_cl_lo$IshInvMo)
  hist(datamo_cl_lo$IshInvMo[datamo_cl_lo$Forest=="Paracou"])
hist(datamo_cl_lo$TxLogg)
 hist(datamo_cl_lo$TxLogg[datamo_cl_lo$Forest=="Paracou"])

ggplot(datamo_cl_lo)+
  geom_histogram(aes(x=Year1))+
  facet_wrap(~Forest,scale="free")

ggplot(datacr_cl_lo)+
  geom_histogram(aes(x=Year1))+
  facet_wrap(~Forest,scale="free")
ggplot(datacr_cl_lo)+
  geom_histogram(aes(x=IshInv))+
  facet_wrap(~Forest,scale="free")

test<-datamo_cl_lo %>%
  group_by(Forest) %>%
  summarise(nbmes=n(), NbYear1=n_distinct(Year1), NbYear2=n_distinct(Year2))

test_cr<-datacr_cl_lo %>%
  group_by(Forest) %>%
  summarise(nbmes=n(), NbYear1=n_distinct(Year1), NbYear2=n_distinct(Year2))

test2<-datamo_cl_lo %>%
  group_by(Forest) %>%
  summarise(nbmes=n(), Nbclim=n_distinct(IshInvMo)) %>% 
  left_join(select(test,-nbmes),by="Forest")

test_nouragues<-datamo_cl_lo %>%
    filter(Forest=="Nouragues") %>%
    group_by(Year1) %>%
    summarise(nbmes=n(), meanclim=mean(IshInvMo), nbna=sum(is.na(IshInvMo)))

test_date<-tabMesuresSelect %>% 
  group_by(Forest) %>% 
  summarise(yearmax=max(),yearmin=min(CensusYear)) %>% 
  left_join(dispoMinMaxCensusDate,by="Forest")

test_date2<-tabMesuresSelect %>% 
  arrange(desc(CensusDate))

test_yeardate<-dispoGuyafor %>%  
  select(Forest,CensusYear,CensusDate) %>% 
  distinct() %>% 
  mutate(CDyear=as.numeric(format(as.Date(CensusDate,"%Y-%m-%d"),format = "%Y"))) %>% 
  mutate(test_year=abs(CensusYear-CDyear)) %>% 
  filter(test_year>1) %>% 
  arrange(desc(test_year)) 
save(test_yeardate,file="test_yeardate_guyafor.Rdata")

zoom_yeardate<-dispoGuyafor %>%
  filter(Forest=="BAFOG" & CensusYear==2002 &CensusDate=="2006-03-15") %>% 
  # filter(Forest=="Paracou" & Plot=="9" &CensusDate=="2004-08-27") %>% 
  select(idTree)

zoom_tree<-dispoGuyafor %>% 
  semi_join(zoom_yeardate, by="idTree") %>% 
  arrange(idTree, CensusDate)

  group_by(Forest) %>% 
  summarise(nbpbyear=n())


```
